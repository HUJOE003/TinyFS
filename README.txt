FEATURES: ABDEH
Names: Mateen Shagagi, Hujoe Selvan

How well does your TinyFS implementation work? What tradeoffs were made and why?
Our TinyFS implementation successfully provides core file system functionalities, including file creation, reading, writing, deletion, and block-based disk emulation. Additionally, it supports fragmentation visualization and defragmentation. One tradeoff was optimizing color tracking without excessive rescanning of the disk, achieved by maintaining a persistent inode-color mapping. Another tradeoff was using a simple linked-list approach for data block allocation instead of a more complex indexed allocation, ensuring easier implementation but slightly increasing fragmentation risk.

Which additional functionality areas were implemented, and how were they tested?
We implemented fragmentation visualization and defragmentation by tracking inodes and data blocks using persistent colors, allowing for a clear visual representation of allocated/free blocks before and after defragging. The functionality was tested by creating multiple files, writing varying amounts of data, deleting files, and then running tfs_displayFragments() and tfs_defrag() to confirm that colors and block assignments remained consistent. We also added read-only protection, preventing write operations on flagged files, and timestamps, which store creation, modification, and access times within inodes. These were validated by opening, writing, and reading files while checking timestamps. Additionally, we implemented directory listing and file renaming by iterating over inode blocks and updating the fileâ€™s name field in its inode. Lastly, we also implemented file system consistency checks. It verifies the integrity of the TinyFS file system by checking that the superblock is correctly formatted and contains valid metadata, ensuring the free block list does not contain duplicate or out-of-range entries, validating that all allocated blocks (inode and data blocks) are correctly marked and do not overlap with free blocks, confirming that inode blocks correctly reference valid and non-duplicate data blocks, detecting orphaned data blocks that are not referenced by any inode, and ultimately returning 0 if the file system is consistent or a negative error code if any inconsistency, corruption, or structural error is found. We tested this by manually editting the disk to simulate corruption to determien whether the checks worked correctly.

What limitations or bugs exist in the current TinyFS implementation?
A limitation of this implementation is that defragmentation requires full reallocation of files and updates to inode pointers, which could be optimized to be more efficient. Additionally, file size is limited by the linear linked-list data structure rather than a more sophisticated indexing method. One potential bug is that if a system crash occurs mid-operation, file metadata may become inconsistent, as there is no journaling or crash recovery. Lastly, large file support is constrained by the number of available blocks, and there is no built-in mechanism for dynamically resizing the disk.
